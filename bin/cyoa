#!/usr/bin/env perl
# -*-Perl-*-
use autodie qw":all";
use common::sense;
use diagnostics;
use warnings qw"all";

use File::Basename;
use CYOA;
use Switch;
use Getopt::Long qw"GetOptionsFromArray";

=head1 NAME

    cyoa - Choose Your Own Adventure!  (In Sequence Processing)

=head1 SYNOPSIS

    ## Starts the menu-based function chooser
    cyoa
    ## Perform an rnaseq specific job to use bwa with the lmajor reference and 2 paired sequence files.
    cyoa --task rnaseq --method bwa --species lmajor --input fwd_reads.fastq.gz:rev_reads.fastq.gz

=head2 Methods & Globals

=over 4

=item C<menus>

    The global variable $menus keeps a set of silly choose your own
    adventure quotes along with the possible task->method listings.
    The choices slot in each key of the hash is a list of function
    names found in CYOA::something.  The assumption is that all the
    functions use Check_Options() to ensure that they receive all the
    relevant parameters.

=cut

## Going to pull an initial instance of cyoa in order to handle command line arguments
our $cyoa = new CYOA;
our $term = $cyoa->{term};
## I am going to use Getopt::Long to turn possible things TODO on, they start all off.
## Use this hash to define the menu system and options available to each toplevel task
our $menus = $cyoa->{menus};

## The general idea is to have a toplevel 'task' to perform
## Something like TNSeq, RNASeq, etc
##  Then a second-level method to perform therein, which will provide a match to the appropriate function
if (!defined($cyoa->{task})) {  ## If task is not defined, then we need to run Main()
    Main();
} elsif (!defined($cyoa->{method})) { ## If task is defined, but method is not, use the menu system to get that information
    Iterate(task => $cyoa->{task}, cyoa => $cyoa);
} else {
    Match_Method(task => $cyoa->{task}, cyoa => $cyoa, method => $cyoa->{method});
}


sub Main {
    my $finished = 0;
    while ($finished != 1) {
        my @choices = sort keys(%{$menus});
        my $top_level = $term->get_reply(
            prompt => 'Choose your adventure!',
            choices => \@choices,
            default => 'TNSeq',);

        Iterate(task => $top_level);

        my $bool = $term->ask_yn(
            prompt => 'Are you done?',
            default => 'n',
            );
        $finished = 1 if ($bool eq '1');
        #my $string = q[some_command -option --no-foo --quux='this thing'];
        #my ($options,$munged_input) = $term->parse_options($string);
        ### don't have Term::UI issue warnings -- default is '1'

        ### Retrieve the entire session as a printable string:
        #$hist = Term::UI::History->history_as_string;
        #$hist = $term->history_as_string;
    } ## End while not finished.
}

sub Iterate {
    my %args = @_;
    my $type = $args{task};
    my $finished = 0;
    while ($finished != 1) {
        my $task = $term->get_reply(
            prompt => $menus->{$type}->{message},
            choices => $menus->{$type}->{choices},
            );
        if ($task eq 'Cutadapt' or $task =~ /Trim/) {
            my $new_input = basename($cyoa->{input}, @{$cyoa->{suffixes}}) . "-trimmed.fastq";
            $cyoa->{input} = $new_input;
            print "I perceive that thou dost perform a trimming operation, resetting the input to $new_input.\n";
        }
        $cyoa->$task(type => $type);

        my $bool = $term->ask_yn(
            prompt => 'Go back to the toplevel?',
            default => 'n',
            );
        if ($bool eq '1') {
            $finished = 1;
            my $reset = $term->get_reply(
                prompt => 'How many of your parameters do you want to reset?',
                choices => ['Everything', 'Just input', 'Nothing'],
                default => 'Just input');
            if ($reset eq 'Just input') {
                $cyoa->{input} = undef;
            } elsif ($reset eq 'Everything') {
                $cyoa->{input} = undef;
                $cyoa->{species} = undef;
                ## Some other stuff which I can't remember now
            } else {
                ## Leave $cyoa alone
            }
        }
    } ## End the task while loop
}

sub Match_Method {
    my %args = @_;
    my $type = $args{task};
    my $m = '--' . $args{method};
    my @method = ($m,);
    my %methods = %{$cyoa->{methods}};
    ## This way, we can trivially make an array to pass to GetOptionsFromArray()
    my $array_result = GetOptionsFromArray(\@method, %methods);
    my %todo = %{$cyoa->{todo}};
    ## Now some portions of $cyoa->{todo} should be filled in with 1s
    foreach my $job (keys %todo) {
        if ($todo{$job}) {
            print "You chose to perform: $job\n";
            my $process = $cyoa->$job(type => $type);
            if ($process->{pbs_id}) {
                my $print_job = new FileHandle;
                $print_job->open(">last_job.txt");
                print $print_job "$process->{pbs_id}\n";
                $print_job->close();
            }
            $cyoa->{todo}{$job} = 0;
        }
    }
}

=back

=head1 AUTHOR - atb

Email abelew@gmail.com

=head1 SEE ALSO

    L<CYOA> L<CYOA::Convert> L<CYOA::RNASeq_Trim>

=cut

## EOF
